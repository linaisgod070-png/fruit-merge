<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ğŸ”¥ çƒ­æ¢—åˆæˆ</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@700;900&display=swap');
body {
  background: #1a1a2e;
  background-image: radial-gradient(circle at 30% 20%, #16213e 0%, transparent 50%),
                    radial-gradient(circle at 70% 80%, #0f3460 0%, transparent 50%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  height: 100vh; font-family: 'Nunito', sans-serif; overflow: hidden; touch-action: none;
}
#header { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
#header h1 { font-size: 24px; font-weight: 900; color: #e94560; text-shadow: 0 2px 0 rgba(0,0,0,0.3); }
.score-box { background: rgba(255,255,255,0.1); border-radius: 14px; padding: 4px 14px; text-align: center; box-shadow: 0 2px 8px rgba(0,0,0,0.2); border: 2px solid #e94560; }
.score-box .label { font-size: 9px; color: #e94560; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
.score-box .value { font-size: 20px; color: #fff; font-weight: 900; }
#multiplier { background: rgba(255,255,255,0.1); border-radius: 14px; padding: 4px 12px; text-align: center; box-shadow: 0 2px 8px rgba(0,0,0,0.2); border: 2px solid #ff6b6b; display: none; }
#multiplier .label { font-size: 9px; color: #ff6b6b; font-weight: 700; }
#multiplier .value { font-size: 20px; color: #ff6b6b; font-weight: 900; }
#lb-btn { background: rgba(255,255,255,0.1); border: 2px solid #e94560; border-radius: 14px; padding: 4px 12px; font-size: 18px; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.2); color: #fff; }
#lb-btn:active { transform: scale(0.95); }
#game-area { position: relative; width: 360px; }
#game-container {
  position: relative; width: 360px; height: 520px;
  background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
  border: 4px solid #e94560; border-top: none; border-radius: 0 0 20px 20px;
  overflow: hidden; box-shadow: 0 8px 32px rgba(233,69,96,0.2), inset 0 0 30px rgba(233,69,96,0.05);
}
#game-container canvas { clip-path: inset(0 0 0 0 round 0 0 20px 20px); }
#top-bar {
  width: 360px; height: 50px; background: linear-gradient(180deg, #e94560, #c23152);
  border-radius: 16px 16px 0 0; display: flex; align-items: center; justify-content: center;
  padding: 0 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
#next-box { display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.2); border-radius: 10px; padding: 4px 10px; }
#next-box .lbl { font-size: 11px; color: rgba(255,255,255,0.8); font-weight: 700; }
#next-emoji { font-size: 22px; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3)); }
#danger-line { position: absolute; top: 60px; left: 8px; right: 8px; height: 2px; background: repeating-linear-gradient(90deg, #ff6b6b 0, #ff6b6b 8px, transparent 8px, transparent 16px); opacity: 0.4; z-index: 5; }
canvas { display: block; }
#game-over { display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(26,26,46,0.95); backdrop-filter: blur(4px); z-index: 20; flex-direction: column; align-items: center; justify-content: center; }
#game-over h2 { font-size: 36px; color: #e94560; font-weight: 900; margin-bottom: 4px; }
#game-over .sub { font-size: 14px; color: #aaa; margin-bottom: 8px; }
#stars { font-size: 40px; margin-bottom: 8px; }
#final-score { font-size: 56px; font-weight: 900; color: #e94560; margin-bottom: 6px; text-shadow: 0 3px 0 #c23152; }
#achievements { font-size: 13px; color: #aaa; margin-bottom: 16px; min-height: 20px; }
#restart-btn { padding: 14px 48px; font-size: 18px; font-weight: 900; font-family: 'Nunito', sans-serif; background: linear-gradient(180deg, #e94560, #c23152); color: #fff; border: 3px solid #a02040; border-radius: 50px; cursor: pointer; box-shadow: 0 4px 0 #8b1a35, 0 6px 16px rgba(233,69,96,0.3); transition: transform 0.1s; }
#restart-btn:active { transform: translateY(3px); box-shadow: 0 1px 0 #8b1a35; }
#combo { position: absolute; top: 40%; left: 50%; transform: translate(-50%,-50%); font-size: 32px; font-weight: 900; color: #e94560; text-shadow: 0 2px 0 #c23152; z-index: 15; pointer-events: none; opacity: 0; transition: opacity 0.3s; }
</style>
</head>
<body>
<div id="header">
  <h1>ğŸ”¥ çƒ­æ¢—åˆæˆ</h1>
  <div class="score-box"><div class="label">åˆ†æ•°</div><div class="value" id="score">0</div></div>
  <div class="score-box"><div class="label">æœ€é«˜</div><div class="value" id="best">0</div></div>
  <div id="multiplier"><div class="label">å€ç‡</div><div class="value" id="mult-val">x1</div></div>
  <button id="lb-btn">ğŸ†</button>
</div>
<div id="game-area">
  <div id="top-bar">
    <div id="next-box"><span class="lbl">NEXT</span><span id="next-emoji">ğŸ±</span></div>
  </div>
  <div id="game-container">
    <div id="danger-line"></div>
    <div id="combo"></div>
    <canvas id="canvas" width="360" height="520"></canvas>
    <div id="game-over">
      <h2>GAME OVER</h2>
      <div class="sub">å†æ¥ä¸€æŠŠï¼Ÿä½ å¯ä»¥çš„ï¼</div>
      <div id="stars"></div>
      <div id="final-score">0</div>
      <div id="achievements"></div>
      <button id="restart-btn">ğŸ”„ å†æ¥</button>
    </div>
  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, Body, Composite, Events } = Matter;

// ===== éŸ³æ•ˆ =====
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ac() { if (!audioCtx) audioCtx = new AudioCtx(); return audioCtx; }
function noiseBuffer(dur) {
  dur = dur || 0.05;
  const c = ac(), buf = c.createBuffer(1, c.sampleRate * dur, c.sampleRate), d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.5; return buf;
}
function playTone(freq, type, vol, dur, slide) {
  const c = ac(), t = c.currentTime;
  const o = c.createOscillator(), g = c.createGain();
  o.type = type || 'sine'; o.frequency.setValueAtTime(freq, t);
  if (slide) o.frequency.exponentialRampToValueAtTime(slide, t + dur);
  g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  o.connect(g); g.connect(c.destination); o.start(t); o.stop(t + dur);
}

// å“ˆåŸºç±³ï¼šçŒ«å« å–µ~ï¼ˆé«˜é¢‘æ»‘éŸ³+å™ªå£°æ°”æ¯ï¼‰
function sfxHakimi() {
  const c = ac(), t = c.currentTime;
  // ä¸»éŸ³ï¼šé«˜é¢‘ä¸‹æ»‘æ¨¡æ‹ŸçŒ«å«
  const o = c.createOscillator(), g = c.createGain();
  o.type = 'sine'; o.frequency.setValueAtTime(900, t);
  o.frequency.linearRampToValueAtTime(1200, t + 0.05);
  o.frequency.exponentialRampToValueAtTime(600, t + 0.25);
  g.gain.setValueAtTime(0.25, t); g.gain.linearRampToValueAtTime(0.3, t + 0.05);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
  o.connect(g); g.connect(c.destination); o.start(t); o.stop(t + 0.3);
  // æ³›éŸ³
  const o2 = c.createOscillator(), g2 = c.createGain();
  o2.type = 'triangle'; o2.frequency.setValueAtTime(1800, t);
  o2.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
  g2.gain.setValueAtTime(0.08, t); g2.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
  o2.connect(g2); g2.connect(c.destination); o2.start(t); o2.stop(t + 0.2);
}

// å¡çš®å·´æ‹‰ï¼šä½æ²‰ä½›ç³» å—¯~
function sfxCapybara() {
  const c = ac(), t = c.currentTime;
  const o = c.createOscillator(), g = c.createGain();
  o.type = 'sine'; o.frequency.setValueAtTime(180, t);
  o.frequency.linearRampToValueAtTime(200, t + 0.1);
  o.frequency.exponentialRampToValueAtTime(150, t + 0.35);
  g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
  o.connect(g); g.connect(c.destination); o.start(t); o.stop(t + 0.4);
  // ä½é¢‘å…±é¸£
  const o2 = c.createOscillator(), g2 = c.createGain();
  o2.type = 'triangle'; o2.frequency.setValueAtTime(90, t);
  g2.gain.setValueAtTime(0.15, t); g2.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
  o2.connect(g2); g2.connect(c.destination); o2.start(t); o2.stop(t + 0.35);
}

// éœ²æ¯”ï¼šå¯çˆ±å®~ é«˜é¢‘é“ƒå£°
function sfxLoopy() {
  const c = ac(), t = c.currentTime;
  [1200, 1500, 1800].forEach((f, i) => {
    const o = c.createOscillator(), g = c.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(f, t + i * 0.06);
    g.gain.setValueAtTime(0.2, t + i * 0.06);
    g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.06 + 0.15);
    o.connect(g); g.connect(c.destination); o.start(t + i * 0.06); o.stop(t + i * 0.06 + 0.15);
  });
}

// å‰ä¼Šå¡å“‡ï¼šè½¯èŒ å“‡~ ä¸Šæ»‘éŸ³
function sfxChiikawa() {
  const c = ac(), t = c.currentTime;
  const o = c.createOscillator(), g = c.createGain();
  o.type = 'sine'; o.frequency.setValueAtTime(500, t);
  o.frequency.linearRampToValueAtTime(900, t + 0.12);
  o.frequency.exponentialRampToValueAtTime(700, t + 0.3);
  g.gain.setValueAtTime(0.25, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
  o.connect(g); g.connect(c.destination); o.start(t); o.stop(t + 0.35);
  // å¯çˆ±æ³›éŸ³
  setTimeout(() => playTone(1400, 'sine', 0.08, 0.12), 50);
}

// æˆ‘çš„åˆ€ç›¾ï¼šé‡‘å±ç¢°æ’
function sfxShield() {
  const c = ac(), t = c.currentTime;
  // é‡‘å±æ’å‡»ï¼šé«˜é¢‘å™ªå£° + å…±é¸£
  const ns = c.createBufferSource(), ng = c.createGain(), bp = c.createBiquadFilter();
  bp.type = 'bandpass'; bp.frequency.value = 4000; bp.Q.value = 8;
  ns.buffer = noiseBuffer(0.08); ng.gain.setValueAtTime(0.4, t);
  ng.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  ns.connect(bp); bp.connect(ng); ng.connect(c.destination); ns.start(t); ns.stop(t + 0.1);
  // é‡‘å±å…±é¸£
  [2200, 3300].forEach(f => {
    const o = c.createOscillator(), g = c.createGain();
    o.type = 'square'; o.frequency.setValueAtTime(f, t);
    o.frequency.exponentialRampToValueAtTime(f * 0.5, t + 0.2);
    g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
    o.connect(g); g.connect(c.destination); o.start(t); o.stop(t + 0.25);
  });
}

// ä½ åœ¨æ•™æˆ‘åšäº‹ï¼šä½æ²‰ å—¯ï¼Ÿ ç–‘é—®ä¸Šæ‰¬
function sfxTeach() {
  const c = ac(), t = c.currentTime;
  const o = c.createOscillator(), g = c.createGain();
  o.type = 'sawtooth'; o.frequency.setValueAtTime(200, t);
  o.frequency.setValueAtTime(200, t + 0.15);
  o.frequency.linearRampToValueAtTime(350, t + 0.25);
  g.gain.setValueAtTime(0.2, t); g.gain.setValueAtTime(0.2, t + 0.2);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
  o.connect(g); g.connect(c.destination); o.start(t); o.stop(t + 0.35);
}

// ç§‘ç›®ä¸‰ï¼šèŠ‚å¥é¼“ç‚¹ å’šå“’å’šå“’
function sfxKemu3() {
  const c = ac(), t = c.currentTime;
  [0, 0.1, 0.2, 0.3].forEach((d, i) => {
    const f = i % 2 === 0 ? 100 : 250;
    const o = c.createOscillator(), g = c.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(f, t + d);
    o.frequency.exponentialRampToValueAtTime(f * 0.3, t + d + 0.08);
    g.gain.setValueAtTime(0.3, t + d); g.gain.exponentialRampToValueAtTime(0.001, t + d + 0.08);
    o.connect(g); g.connect(c.destination); o.start(t + d); o.stop(t + d + 0.08);
    // å™ªå£°æ‰“å‡»
    const ns = c.createBufferSource(), ng = c.createGain();
    ns.buffer = noiseBuffer(0.03); ng.gain.setValueAtTime(i % 2 === 0 ? 0.15 : 0.25, t + d);
    ng.gain.exponentialRampToValueAtTime(0.001, t + d + 0.05);
    ns.connect(ng); ng.connect(c.destination); ns.start(t + d); ns.stop(t + d + 0.05);
  });
}

// é¥é¥é¢†å…ˆï¼šä¸Šå‡éŸ³é˜¶ do re mi fa
function sfxLeading() {
  const c = ac(), t = c.currentTime;
  [523, 659, 784, 1047].forEach((f, i) => {
    const o = c.createOscillator(), g = c.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(f, t + i * 0.08);
    g.gain.setValueAtTime(0.2, t + i * 0.08);
    g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.12);
    o.connect(g); g.connect(c.destination); o.start(t + i * 0.08); o.stop(t + i * 0.08 + 0.12);
  });
}

// 6ï¼šç”µå­ "å…­å…­å…­" ä¸‰è¿éŸ³
function sfxLiu() {
  const c = ac(), t = c.currentTime;
  [0, 0.1, 0.2].forEach(d => {
    const o = c.createOscillator(), g = c.createGain();
    o.type = 'square'; o.frequency.setValueAtTime(660, t + d);
    o.frequency.linearRampToValueAtTime(880, t + d + 0.04);
    o.frequency.exponentialRampToValueAtTime(660, t + d + 0.08);
    g.gain.setValueAtTime(0.15, t + d); g.gain.exponentialRampToValueAtTime(0.001, t + d + 0.1);
    o.connect(g); g.connect(c.destination); o.start(t + d); o.stop(t + d + 0.1);
  });
}

// ä½ æ˜¯æ‡‚çš„ï¼šçš‡å† åŠ å†• åä¸½å’Œå¼¦
function sfxKing() {
  const c = ac(), t = c.currentTime;
  // å’Œå¼¦ï¼šC E G C'
  [523, 659, 784, 1047].forEach((f, i) => {
    const o = c.createOscillator(), g = c.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(f, t);
    g.gain.setValueAtTime(0.15, t); g.gain.linearRampToValueAtTime(0.2, t + 0.1);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
    o.connect(g); g.connect(c.destination); o.start(t); o.stop(t + 0.5);
  });
  // é—ªäº®éŸ³æ•ˆ
  setTimeout(() => { playTone(2000, 'sine', 0.1, 0.15, 2500); }, 100);
  setTimeout(() => { playTone(2500, 'sine', 0.08, 0.12, 3000); }, 200);
}

// åˆæˆéŸ³æ•ˆåˆ†å‘
const MERGE_SFX = [sfxHakimi, sfxCapybara, sfxLoopy, sfxChiikawa, sfxShield, sfxTeach, sfxKemu3, sfxLeading, sfxLiu, sfxKing];

function playDrop() { playTone(800, 'sine', 0.15, 0.1, 400); }
function playMerge(level) { if (MERGE_SFX[level]) MERGE_SFX[level](); }
function playSpecial() { playTone(1200, 'sine', 0.3, 0.1); setTimeout(() => playTone(1500, 'sine', 0.2, 0.1), 60); setTimeout(() => playTone(1800, 'sine', 0.15, 0.1), 120); }
function playCombo(n) { playTone(600+n*150, 'sine', 0.2, 0.12); setTimeout(() => playTone(800+n*150, 'sine', 0.15, 0.1), 50); }
function playGameOver() { const c=ac(),t=c.currentTime; [350,280,200].forEach((f,i) => { const o=c.createOscillator(),g=c.createGain(); o.type='sine'; o.frequency.setValueAtTime(f,t+i*0.18); o.frequency.exponentialRampToValueAtTime(f*0.5,t+i*0.18+0.35); g.gain.setValueAtTime(0.2,t+i*0.18); g.gain.exponentialRampToValueAtTime(0.001,t+i*0.18+0.4); o.connect(g); g.connect(c.destination); o.start(t+i*0.18); o.stop(t+i*0.18+0.4); }); }

// ===== çƒ­æ¢—é…ç½® =====
// [åç§°, åŠå¾„, ä¸»è‰², åˆ†æ•°, æè¾¹è‰², é«˜å…‰è‰², æ ‡ç­¾]
const MEMES = [
  ['ğŸ±', 16, '#FFB6C1', 1, '#FF69B4', '#FFD1DC', 'å“ˆåŸºç±³'],
  ['ğŸ¦«', 21, '#C4A882', 2, '#8B7355', '#DEC4A1', 'å¡çš®å·´æ‹‰'],
  ['ğŸ°', 27, '#FF8FAB', 4, '#FF5C8A', '#FFB3C6', 'éœ²æ¯”Loopy'],
  ['ğŸ»', 32, '#B8E6B8', 8, '#7BC67B', '#D4F0D4', 'å‰ä¼Šå¡å“‡'],
  ['ğŸ›¡ï¸', 38, '#7EB8DA', 16, '#4A90B8', '#A8D4ED', 'æˆ‘çš„åˆ€ç›¾'],
  ['ğŸ˜', 44, '#FFD700', 32, '#DAA520', '#FFEC8B', 'ä½ åœ¨æ•™æˆ‘åšäº‹'],
  ['ğŸ’ƒ', 52, '#FF6B6B', 64, '#E94560', '#FF9B9B', 'ç§‘ç›®ä¸‰'],
  ['ğŸ§ ', 58, '#9B59B6', 128, '#8E44AD', '#BB8FCE', 'é¥é¥é¢†å…ˆ'],
  ['ğŸ­', 65, '#FF4757', 256, '#C0392B', '#FF6B81', '6'],
  ['ğŸ‘‘', 75, '#F1C40F', 512, '#D4AC0D', '#F9E154', 'ä½ æ˜¯æ‡‚çš„'],
];

const SPECIAL = { BOMB: 'bomb', RAINBOW: 'rainbow', FREEZE: 'freeze' };
const SPECIAL_EMOJI = { bomb: 'ğŸ’£', rainbow: 'ğŸŒˆ', freeze: 'ğŸ§Š' };
const SPECIAL_COLOR = { bomb: '#1f2937', rainbow: '#ec4899', freeze: '#67e8f9' };

const W = 360, H = 520, DANGER_Y = 60, WALL = 8, DROP_Y = 30;
let engine, render, runner, score = 0, bestScore = 0, gameOver = false;
let currentLevel = 0, nextLevel = 0, dropping = false, cooldown = false;
let previewX = W / 2, particles = [], floatTexts = [];
let comboCount = 0, comboTimer = null, multiplier = 1, multTimer = null;
let maxLevel = 0, mergeCount = 0, specialUsed = 0, dropCount = 0;
let gameOverCheckInterval, frozen = false, frozenTimer = null;
let nextSpecial = null, currentSpecial = null;

const $ = id => document.getElementById(id);
const scoreEl=$('score'), bestEl=$('best'), nextEl=$('next-emoji');
const overEl=$('game-over'), finalEl=$('final-score'), comboEl=$('combo');
const multEl=$('multiplier'), multValEl=$('mult-val');
const starsEl=$('stars'), achieveEl=$('achievements');
const canvas=$('canvas');

bestScore = parseInt(localStorage.getItem('meme-best') || '0');
bestEl.textContent = bestScore;

// ===== è‡ªå®šä¹‰ç»˜åˆ¶å‡½æ•° =====
function drawMemeBody(ctx, x, y, r, level) {
  const [, , fill, , stroke, hi] = MEMES[level];
  const age = Date.now() - (arguments[5] || 0);
  const scale = age < 150 ? 0.5 + 0.5 * Math.min(1, age / 150) * (1 + 0.2 * Math.sin(age / 30)) : 1;
  const sr = r * scale;
  // æ¸å˜ä¸»ä½“
  const grad = ctx.createRadialGradient(x - sr*0.3, y - sr*0.3, sr*0.1, x, y, sr);
  grad.addColorStop(0, hi); grad.addColorStop(0.5, fill); grad.addColorStop(1, stroke);
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(x, y, sr, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = stroke; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.arc(x, y, sr, 0, Math.PI*2); ctx.stroke();
  // é«˜å…‰
  ctx.globalAlpha = 0.3; ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.ellipse(x - sr*0.2, y - sr*0.3, sr*0.45, sr*0.22, -0.3, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
  return sr;
}

// ç”»å“ˆåŸºç±³çŒ«è€³æœµ
function drawCatEars(ctx, x, y, r, color) {
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.moveTo(x-r*0.7, y-r*0.4); ctx.lineTo(x-r*0.9, y-r*1.1); ctx.lineTo(x-r*0.15, y-r*0.75); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x+r*0.7, y-r*0.4); ctx.lineTo(x+r*0.9, y-r*1.1); ctx.lineTo(x+r*0.15, y-r*0.75); ctx.fill();
  // å†…è€³
  ctx.fillStyle = '#FFB6C1';
  ctx.beginPath(); ctx.moveTo(x-r*0.6, y-r*0.5); ctx.lineTo(x-r*0.78, y-r*0.95); ctx.lineTo(x-r*0.25, y-r*0.72); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x+r*0.6, y-r*0.5); ctx.lineTo(x+r*0.78, y-r*0.95); ctx.lineTo(x+r*0.25, y-r*0.72); ctx.fill();
}

// ç”»å…”è€³æœµï¼ˆéœ²æ¯”ï¼‰
function drawBunnyEars(ctx, x, y, r, color) {
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.ellipse(x-r*0.4, y-r*1.2, r*0.22, r*0.55, -0.15, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x+r*0.4, y-r*1.2, r*0.22, r*0.55, 0.15, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#FF8FAB';
  ctx.beginPath(); ctx.ellipse(x-r*0.4, y-r*1.2, r*0.13, r*0.4, -0.15, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x+r*0.4, y-r*1.2, r*0.13, r*0.4, 0.15, 0, Math.PI*2); ctx.fill();
}

// ç”»å¯çˆ±çœ¼ç›
function drawCuteEyes(ctx, x, y, r, style) {
  const eyeR = r * 0.15;
  if (style === 'dot') {
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(x-r*0.25, y-r*0.05, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.25, y-r*0.05, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(x-r*0.22, y-r*0.1, eyeR*0.4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.28, y-r*0.1, eyeR*0.4, 0, Math.PI*2); ctx.fill();
  } else if (style === 'happy') {
    ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.arc(x-r*0.25, y, eyeR*1.2, Math.PI, 0); ctx.stroke();
    ctx.beginPath(); ctx.arc(x+r*0.25, y, eyeR*1.2, Math.PI, 0); ctx.stroke();
  } else if (style === 'star') {
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(x-r*0.25, y-r*0.05, eyeR*1.3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.25, y-r*0.05, eyeR*1.3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#FFD700';
    ctx.font = (eyeR*2.5) + 'px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('â˜…', x-r*0.25, y-r*0.05); ctx.fillText('â˜…', x+r*0.25, y-r*0.05);
  } else if (style === 'big') {
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(x-r*0.25, y-r*0.05, eyeR*1.8, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.25, y-r*0.05, eyeR*1.8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(x-r*0.22, y-r*0.02, eyeR*1.1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.22, y-r*0.02, eyeR*1.1, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(x-r*0.19, y-r*0.08, eyeR*0.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.25, y-r*0.08, eyeR*0.5, 0, Math.PI*2); ctx.fill();
  } else {
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(x-r*0.25, y-r*0.05, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.25, y-r*0.05, eyeR, 0, Math.PI*2); ctx.fill();
  }
}

// ç”»å˜´å·´
function drawMouth(ctx, x, y, r, style) {
  ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5; ctx.lineCap = 'round';
  if (style === 'smile') {
    ctx.beginPath(); ctx.arc(x, y+r*0.15, r*0.2, 0.1, Math.PI-0.1); ctx.stroke();
  } else if (style === 'cat') {
    ctx.beginPath(); ctx.moveTo(x, y+r*0.2); ctx.lineTo(x-r*0.2, y+r*0.35); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y+r*0.2); ctx.lineTo(x+r*0.2, y+r*0.35); ctx.stroke();
  } else if (style === 'o') {
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.ellipse(x, y+r*0.25, r*0.1, r*0.12, 0, 0, Math.PI*2); ctx.fill();
  } else if (style === 'flat') {
    ctx.beginPath(); ctx.moveTo(x-r*0.15, y+r*0.2); ctx.lineTo(x+r*0.15, y+r*0.2); ctx.stroke();
  } else if (style === 'grin') {
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(x, y+r*0.15, r*0.22, 0, Math.PI); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(x, y+r*0.15, r*0.22, 0.2, Math.PI-0.2); ctx.fill();
  }
}

// ç”»è…®çº¢
function drawBlush(ctx, x, y, r) {
  ctx.globalAlpha = 0.3; ctx.fillStyle = '#FF6B6B';
  ctx.beginPath(); ctx.ellipse(x-r*0.45, y+r*0.15, r*0.15, r*0.1, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x+r*0.45, y+r*0.15, r*0.15, r*0.1, 0, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
}

// ===== æ¯ä¸ªæ¢—çš„ç»˜åˆ¶ =====
function drawMeme(ctx, body) {
  const level = body.fruitLevel;
  const [emoji, r, fill, , stroke, hi, label] = MEMES[level];
  const x = body.position.x, y = body.position.y;
  const age = Date.now() - (body.birthTime || 0);
  const scale = age < 150 ? 0.5 + 0.5 * Math.min(1, age / 150) * (1 + 0.2 * Math.sin(age / 30)) : 1;
  const sr = r * scale;
  // æ¸å˜ä¸»ä½“
  const grad = ctx.createRadialGradient(x - sr*0.3, y - sr*0.3, sr*0.1, x, y, sr);
  grad.addColorStop(0, hi); grad.addColorStop(0.5, fill); grad.addColorStop(1, stroke);
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(x, y, sr, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = stroke; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.arc(x, y, sr, 0, Math.PI*2); ctx.stroke();
  // é«˜å…‰
  ctx.globalAlpha = 0.3; ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.ellipse(x - sr*0.2, y - sr*0.3, sr*0.45, sr*0.22, -0.3, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  switch(level) {
    case 0: // å“ˆåŸºç±³ - çŒ«
      drawCatEars(ctx, x, y, sr, '#FFB6C1');
      drawCuteEyes(ctx, x, y, sr, 'big');
      drawMouth(ctx, x, y, sr, 'cat');
      drawBlush(ctx, x, y, sr);
      // èƒ¡é¡»
      ctx.strokeStyle = '#999'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x-sr*0.6,y+sr*0.05); ctx.lineTo(x-sr*0.2,y+sr*0.12); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x-sr*0.55,y+sr*0.2); ctx.lineTo(x-sr*0.2,y+sr*0.2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+sr*0.6,y+sr*0.05); ctx.lineTo(x+sr*0.2,y+sr*0.12); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+sr*0.55,y+sr*0.2); ctx.lineTo(x+sr*0.2,y+sr*0.2); ctx.stroke();
      break;
    case 1: // å¡çš®å·´æ‹‰ - æ°´è±š
      drawCuteEyes(ctx, x, y, sr, 'dot');
      drawMouth(ctx, x, y, sr, 'flat');
      // å°è€³æœµ
      ctx.fillStyle = '#8B7355';
      ctx.beginPath(); ctx.ellipse(x-sr*0.65,y-sr*0.55,sr*0.18,sr*0.12,-.3,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(x+sr*0.65,y-sr*0.55,sr*0.18,sr*0.12,.3,0,Math.PI*2); ctx.fill();
      // é¼»å­
      ctx.fillStyle = '#6B5344';
      ctx.beginPath(); ctx.ellipse(x,y+sr*0.08,sr*0.12,sr*0.08,0,0,Math.PI*2); ctx.fill();
      break;
    case 2: // éœ²æ¯”Loopy
      drawBunnyEars(ctx, x, y, sr, '#FF8FAB');
      drawCuteEyes(ctx, x, y, sr, 'big');
      drawMouth(ctx, x, y, sr, 'smile');
      drawBlush(ctx, x, y, sr);
      break;
    case 3: // å‰ä¼Šå¡å“‡
      drawCuteEyes(ctx, x, y, sr, 'big');
      drawMouth(ctx, x, y, sr, 'o');
      drawBlush(ctx, x, y, sr);
      // å°è€³æœµ
      ctx.fillStyle = '#B8E6B8';
      ctx.beginPath(); ctx.ellipse(x-sr*0.6,y-sr*0.7,sr*0.2,sr*0.25,-.2,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(x+sr*0.6,y-sr*0.7,sr*0.2,sr*0.25,.2,0,Math.PI*2); ctx.fill();
      break;
    case 4: // æˆ‘çš„åˆ€ç›¾
      drawCuteEyes(ctx, x, y, sr, 'dot');
      drawMouth(ctx, x, y, sr, 'grin');
      // ç›¾ç‰Œæ ‡è®°
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.beginPath(); ctx.moveTo(x,y-sr*0.5); ctx.lineTo(x-sr*0.3,y-sr*0.25);
      ctx.lineTo(x-sr*0.25,y+sr*0.15); ctx.lineTo(x,y+sr*0.35);
      ctx.lineTo(x+sr*0.25,y+sr*0.15); ctx.lineTo(x+sr*0.3,y-sr*0.25); ctx.closePath(); ctx.fill();
      break;
    default: // å…¶ä½™ç”¨ emoji + æ ‡ç­¾
      ctx.font = Math.max(sr * 0.9, 14) + 'px serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(emoji, x, y - sr*0.05);
      if (sr > 30) {
        ctx.font = '900 ' + Math.max(sr*0.28, 9) + 'px Nunito,sans-serif';
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
        ctx.fillText(label, x, y + sr*0.5);
      }
      break;
  }
}

// ===== ç‰¹æ®Šæ°´æœç»˜åˆ¶ =====
function drawSpecial(ctx, body) {
  const x = body.position.x, y = body.position.y, r = 22;
  const type = body.specialType, color = SPECIAL_COLOR[type];
  const t = Date.now() / 300, pulse = 1 + 0.1 * Math.sin(t);
  ctx.fillStyle = color; ctx.globalAlpha = 0.3;
  ctx.beginPath(); ctx.arc(x, y, r * 1.3 * pulse, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
  const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
  grad.addColorStop(0, '#fff'); grad.addColorStop(0.5, color); grad.addColorStop(1, color);
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke();
  ctx.font = '20px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(SPECIAL_EMOJI[type], x, y);
}

// ===== ç²’å­ & é£˜å­— =====
function boom(x, y, color, n) {
  for (let i = 0; i < n; i++) {
    const a = Math.random() * Math.PI * 2, sp = 1.5 + Math.random() * 5;
    particles.push({ x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp - 2, r: 2 + Math.random() * 4, color, life: 1 });
  }
}
function floatText(x, y, text, color) {
  floatTexts.push({ x, y, text, color: color || '#e94560', life: 1, vy: -2 });
}
function drawParticles(ctx) {
  particles = particles.filter(p => {
    p.x += p.vx; p.y += p.vy; p.vy += 0.12; p.life -= 0.035;
    if (p.life <= 0) return false;
    ctx.globalAlpha = p.life * 0.8; ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1; return true;
  });
}
function drawFloatTexts(ctx) {
  floatTexts = floatTexts.filter(ft => {
    ft.y += ft.vy; ft.vy *= 0.98; ft.life -= 0.02;
    if (ft.life <= 0) return false;
    ctx.globalAlpha = ft.life;
    ctx.font = '900 18px Nunito, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = ft.color; ctx.fillText(ft.text, ft.x, ft.y);
    ctx.globalAlpha = 1; return true;
  });
}

// ===== å·¥å…·å‡½æ•° =====
function rndLevel() { return Math.floor(Math.random() * 4); }
function maybeSpecial() {
  if (dropCount > 0 && dropCount % 15 === 0 && Math.random() < 0.2) {
    const types = [SPECIAL.BOMB, SPECIAL.RAINBOW, SPECIAL.FREEZE];
    return types[Math.floor(Math.random() * types.length)];
  }
  return null;
}
function createFruit(x, y, level) {
  const [, r] = MEMES[level];
  return Bodies.circle(x, y, r, {
    restitution: 0.3, friction: 0.5, density: 0.0015, frictionAir: 0.01, slop: 0.01,
    render: { fillStyle: 'transparent', strokeStyle: 'transparent', lineWidth: 0 },
    label: 'fruit', fruitLevel: level, merged: false,
  });
}
function createSpecialFruit(x, y, type) {
  return Bodies.circle(x, y, 22, {
    restitution: 0.3, friction: 0.5, density: 0.0015, frictionAir: 0.01, slop: 0.01,
    render: { fillStyle: 'transparent', strokeStyle: 'transparent', lineWidth: 0 },
    label: 'special', specialType: type, fruitLevel: -1,
  });
}
function updateNext() {
  if (nextSpecial) nextEl.textContent = SPECIAL_EMOJI[nextSpecial];
  else nextEl.textContent = MEMES[nextLevel][0];
}
function addScore(pts) {
  const actual = Math.floor(pts * multiplier);
  score += actual; scoreEl.textContent = score;
  if (score > bestScore) { bestScore = score; bestEl.textContent = bestScore; localStorage.setItem('meme-best', bestScore); }
  return actual;
}
function setMultiplier(m) {
  multiplier = m;
  if (m > 1) { multEl.style.display = 'block'; multValEl.textContent = 'x' + m; }
  else { multEl.style.display = 'none'; }
  clearTimeout(multTimer);
  if (m > 1) multTimer = setTimeout(() => setMultiplier(1), 5000);
}

// ===== æ’è¡Œæ¦œ & æˆå°± =====
function getLB() { return JSON.parse(localStorage.getItem('meme-lb') || '[]'); }
function saveLB(sc) {
  const lb = getLB(), now = new Date();
  lb.push({ score: sc, date: `${now.getMonth()+1}/${now.getDate()} ${now.getHours()}:${String(now.getMinutes()).padStart(2,'0')}` });
  lb.sort((a,b) => b.score - a.score); if (lb.length > 20) lb.length = 20;
  localStorage.setItem('meme-lb', JSON.stringify(lb));
}
function getAchievements() { return JSON.parse(localStorage.getItem('meme-ach') || '{}'); }
function unlockAchievement(key, name) {
  const ach = getAchievements();
  if (!ach[key]) { ach[key] = { name, time: Date.now() }; localStorage.setItem('meme-ach', JSON.stringify(ach)); return name; }
  return null;
}
function checkAchievements() {
  const n = [];
  if (maxLevel >= 6) { const a = unlockAchievement('kemu3', 'ğŸ’ƒ è§£é”ç§‘ç›®ä¸‰ï¼'); if (a) n.push(a); }
  if (maxLevel >= 8) { const a = unlockAchievement('liuliuliu', 'ğŸ­ åˆæˆäº†6ï¼'); if (a) n.push(a); }
  if (maxLevel >= 9) { const a = unlockAchievement('king', 'ğŸ‘‘ ä½ æ˜¯æ‡‚çš„ï¼'); if (a) n.push(a); }
  if (score >= 500) { const a = unlockAchievement('s500', 'ğŸ¯ 500åˆ†ï¼'); if (a) n.push(a); }
  if (score >= 1000) { const a = unlockAchievement('s1000', 'ğŸ”¥ 1000åˆ†ï¼'); if (a) n.push(a); }
  if (comboCount >= 5) { const a = unlockAchievement('c5', 'âš¡ 5è¿å‡»ï¼'); if (a) n.push(a); }
  return n;
}
function getStars(sc) { return sc >= 1000 ? 'â­â­â­' : sc >= 500 ? 'â­â­' : sc >= 100 ? 'â­' : 'ğŸ’«'; }

// ===== ç‰¹æ®Šæ°´æœæ•ˆæœ =====
function activateBomb(x, y) {
  playSpecial(); const radius = 80;
  const bodies = Composite.allBodies(engine.world), toRemove = [];
  for (const b of bodies) {
    if (b.label !== 'fruit' || b.isStatic || b.merged) continue;
    const dx = b.position.x - x, dy = b.position.y - y;
    if (Math.sqrt(dx*dx + dy*dy) < radius + MEMES[b.fruitLevel][1]) {
      toRemove.push(b); addScore(MEMES[b.fruitLevel][3]);
    }
  }
  for (const b of toRemove) { b.merged = true; Composite.remove(engine.world, b); }
  boom(x, y, '#e94560', 30); boom(x, y, '#FF6B6B', 20);
  floatText(x, y, 'ğŸ’¥ BOOM!', '#e94560'); specialUsed++;
}
function activateRainbow(x, y) {
  playSpecial();
  const bodies = Composite.allBodies(engine.world);
  let closest = null, minDist = Infinity;
  for (const b of bodies) {
    if (b.label !== 'fruit' || b.isStatic || b.merged || b.fruitLevel >= MEMES.length - 1) continue;
    const dx = b.position.x - x, dy = b.position.y - y, d = Math.sqrt(dx*dx + dy*dy);
    if (d < minDist) { minDist = d; closest = b; }
  }
  if (closest && minDist < 120) {
    const nl = closest.fruitLevel + 1, nx = closest.position.x, ny = closest.position.y;
    closest.merged = true; Composite.remove(engine.world, closest);
    const nf = createFruit(nx, ny, nl); Composite.add(engine.world, nf);
    boom(nx, ny, MEMES[nl][2], 15); floatText(nx, ny, 'ğŸŒˆ å‡çº§!', '#ec4899');
    addScore(MEMES[nl][3] * 2);
  } else { floatText(x, y, 'ğŸŒˆ æ²¡æ‰¾åˆ°ç›®æ ‡', '#9ca3af'); }
  specialUsed++;
}
function activateFreeze() {
  playSpecial(); frozen = true; engine.gravity.y = 0.3;
  floatText(W/2, H/2, 'ğŸ§Š å‡é€Ÿ!', '#67e8f9');
  clearTimeout(frozenTimer);
  frozenTimer = setTimeout(() => { frozen = false; engine.gravity.y = 1.8; }, 4000);
  specialUsed++;
}

// ===== ä¸»æ¸¸æˆ =====
function initGame() {
  score = 0; gameOver = false; dropping = false; cooldown = false;
  comboCount = 0; particles = []; floatTexts = []; multiplier = 1;
  maxLevel = 0; mergeCount = 0; specialUsed = 0; dropCount = 0;
  frozen = false; nextSpecial = null; currentSpecial = null;
  scoreEl.textContent = '0'; overEl.style.display = 'none';
  comboEl.style.opacity = '0'; multEl.style.display = 'none';
  if (gameOverCheckInterval) clearInterval(gameOverCheckInterval);

  engine = Engine.create({ gravity: { x: 0, y: 1.8 }, positionIterations: 10, velocityIterations: 10, constraintIterations: 4 });
  render = Render.create({ canvas, engine, options: { width: W, height: H, wireframes: false, background: 'transparent' } });

  const wo = { isStatic: true, render: { visible: false }, friction: 0.5 };
  Composite.add(engine.world, [
    Bodies.rectangle(W/2, H - 2, W + 40, 20, { isStatic: true, render: { fillStyle: '#e94560' }, friction: 0.5 }),
    Bodies.rectangle(-15, H/2, 30, H + 50, wo),
    Bodies.rectangle(W + 15, H/2, 30, H + 50, wo),
  ]);

  currentLevel = rndLevel(); nextLevel = rndLevel(); updateNext();

  // ç¢°æ’æ£€æµ‹
  Events.on(engine, 'collisionStart', e => {
    if (gameOver) return;
    const toRemove = [], toAdd = [];
    for (const pair of e.pairs) {
      let a = pair.bodyA, b = pair.bodyB;
      if ((a.label === 'special' || b.label === 'special') && (a.label === 'fruit' || b.label === 'fruit')) {
        const sp = a.label === 'special' ? a : b;
        if (!sp.activated) {
          sp.activated = true; sp.merged = true; Composite.remove(engine.world, sp);
          if (sp.specialType === SPECIAL.BOMB) activateBomb(sp.position.x, sp.position.y);
          else if (sp.specialType === SPECIAL.RAINBOW) activateRainbow(sp.position.x, sp.position.y);
          else if (sp.specialType === SPECIAL.FREEZE) activateFreeze();
        }
        continue;
      }
      if (a.label !== 'fruit' || b.label !== 'fruit') continue;
      if (a.fruitLevel !== b.fruitLevel || a.merged || b.merged) continue;
      if (a.fruitLevel >= MEMES.length - 1) continue;
      a.merged = true; b.merged = true;
      const nl = a.fruitLevel + 1;
      if (nl > maxLevel) maxLevel = nl;
      mergeCount++;
      const mx = (a.position.x + b.position.x) / 2, my = (a.position.y + b.position.y) / 2;
      toRemove.push(a, b);
      const nf = createFruit(mx, my, nl); nf.birthTime = Date.now(); toAdd.push(nf);
      const pts = addScore(MEMES[nl][3]);
      playMerge(nl); boom(mx, my, MEMES[nl][2], 10 + nl * 3);
      floatText(mx, my - 20, '+' + pts, MEMES[nl][4]);
      comboCount++; clearTimeout(comboTimer);
      if (comboCount >= 2) {
        comboEl.textContent = comboCount + 'è¿å‡»! ğŸ”¥';
        comboEl.style.opacity = '1'; comboEl.style.fontSize = (28 + comboCount * 3) + 'px';
        playCombo(comboCount);
      }
      if (comboCount >= 3) setMultiplier(Math.min(comboCount - 1, 5));
      comboTimer = setTimeout(() => { comboCount = 0; comboEl.style.opacity = '0'; }, 1500);
    }
    for (const b of toRemove) Composite.remove(engine.world, b);
    for (const b of toAdd) Composite.add(engine.world, b);
  });

  // æ¸²æŸ“
  Events.on(render, 'afterRender', () => {
    const ctx = render.context;
    for (const body of Composite.allBodies(engine.world)) {
      if (body.merged) continue;
      if (body.label === 'fruit' && body.fruitLevel !== undefined) drawMeme(ctx, body);
      else if (body.label === 'special') drawSpecial(ctx, body);
    }
    drawParticles(ctx); drawFloatTexts(ctx);
    if (frozen) { ctx.globalAlpha = 0.08; ctx.fillStyle = '#67e8f9'; ctx.fillRect(0, 0, W, H); ctx.globalAlpha = 1; }
    // é¢„è§ˆ
    if (!gameOver && !dropping) {
      const px = Math.max(30, Math.min(W - 30, previewX));
      if (currentSpecial) {
        const color = SPECIAL_COLOR[currentSpecial];
        ctx.globalAlpha = 0.5; ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(px, DROP_Y, 22, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1; ctx.font = '20px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(SPECIAL_EMOJI[currentSpecial], px, DROP_Y);
      } else {
        const [cn, cr, cc, , , ch] = MEMES[currentLevel];
        const pGrad = ctx.createRadialGradient(px - cr*0.3, DROP_Y - cr*0.3, cr*0.1, px, DROP_Y, cr);
        pGrad.addColorStop(0, ch); pGrad.addColorStop(0.5, cc); pGrad.addColorStop(1, cc);
        ctx.globalAlpha = 0.5; ctx.fillStyle = pGrad;
        ctx.beginPath(); ctx.arc(px, DROP_Y, cr, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1; ctx.font = Math.max(cr * 0.95, 14) + 'px serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(cn, px, DROP_Y);
      }
      ctx.strokeStyle = 'rgba(233,69,96,0.15)'; ctx.setLineDash([4, 8]);
      ctx.beginPath(); ctx.moveTo(px, DROP_Y + 30); ctx.lineTo(px, H); ctx.stroke(); ctx.setLineDash([]);
    }
  });

  runner = Runner.create(); Render.run(render); Runner.run(runner, engine);

  gameOverCheckInterval = setInterval(() => {
    if (gameOver) return;
    for (const b of Composite.allBodies(engine.world)) {
      if ((b.label !== 'fruit' && b.label !== 'special') || b.isStatic || b.merged) continue;
      const r = b.label === 'special' ? 22 : MEMES[b.fruitLevel][1];
      if (b.position.y - r < DANGER_Y && b.speed < 0.5 && !b.isNew) { endGame(); return; }
      if (b.isNew && Date.now() - b.dropTime > 800) b.isNew = false;
    }
  }, 500);
}

function dropFruit(x) {
  if (gameOver || dropping || cooldown) return;
  x = Math.max(30, Math.min(W - 30, x));
  dropping = true; cooldown = true; dropCount++;
  let f;
  if (currentSpecial) {
    f = createSpecialFruit(x, DROP_Y, currentSpecial); currentSpecial = null;
  } else {
    const [, r] = MEMES[currentLevel];
    x = Math.max(r + WALL + 4, Math.min(W - r - WALL - 4, x));
    f = createFruit(x, DROP_Y, currentLevel); f.birthTime = Date.now();
  }
  f.isNew = true; f.dropTime = Date.now();
  Composite.add(engine.world, f); playDrop();
  currentLevel = nextLevel; currentSpecial = nextSpecial;
  nextSpecial = maybeSpecial(); nextLevel = rndLevel(); updateNext();
  setTimeout(() => dropping = false, 250);
  setTimeout(() => cooldown = false, 450);
}

function endGame() {
  gameOver = true; finalEl.textContent = score;
  starsEl.textContent = getStars(score);
  const newAch = checkAchievements();
  achieveEl.textContent = newAch.length > 0 ? 'ğŸ‰ ' + newAch.join(' | ') : '';
  overEl.style.display = 'flex'; playGameOver(); saveLB(score);
  if (gameOverCheckInterval) clearInterval(gameOverCheckInterval);
}

function cleanup() {
  if (gameOverCheckInterval) clearInterval(gameOverCheckInterval);
  clearTimeout(frozenTimer); clearTimeout(multTimer); clearTimeout(comboTimer);
  if (runner) Runner.stop(runner);
  if (render) Render.stop(render);
  if (engine) { Events.off(engine); Engine.clear(engine); }
}

// ===== æ’è¡Œæ¦œ UI =====
$('lb-btn').addEventListener('click', () => {
  const lb = getLB(), lbEl = document.createElement('div');
  lbEl.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(26,26,46,0.97);z-index:100;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:Nunito,sans-serif;';
  let html = '<h2 style="font-size:28px;color:#e94560;margin-bottom:16px;">ğŸ† æ’è¡Œæ¦œ</h2>';
  html += '<div style="width:280px;max-height:320px;overflow-y:auto;background:rgba(255,255,255,0.05);border-radius:16px;border:2px solid #e94560;box-shadow:0 4px 16px rgba(0,0,0,0.2);">';
  if (lb.length === 0) html += '<div style="padding:20px;text-align:center;color:#aaa;">è¿˜æ²¡æœ‰è®°å½•</div>';
  else lb.forEach((item, i) => {
    const medal = i===0?'ğŸ¥‡':i===1?'ğŸ¥ˆ':i===2?'ğŸ¥‰':(i+1);
    html += `<div style="display:flex;align-items:center;padding:10px 16px;border-bottom:1px solid rgba(255,255,255,0.05);font-size:15px;color:#ddd;"><span style="width:32px;font-weight:900;font-size:18px;">${medal}</span><span style="flex:1;font-weight:700;">ç©å®¶</span><span style="font-weight:900;color:#e94560;">${item.score}</span><span style="font-size:11px;color:#888;margin-left:8px;">${item.date}</span></div>`;
  });
  html += '</div>';
  const ach = getAchievements(), achKeys = Object.keys(ach);
  if (achKeys.length > 0) {
    html += '<div style="margin-top:12px;font-size:14px;color:#e94560;font-weight:700;">ğŸ– æˆå°±</div>';
    html += '<div style="width:280px;margin-top:4px;display:flex;flex-wrap:wrap;gap:6px;justify-content:center;">';
    achKeys.forEach(k => { html += `<span style="background:rgba(255,255,255,0.05);border:1px solid #e94560;border-radius:8px;padding:3px 8px;font-size:12px;color:#ddd;">${ach[k].name}</span>`; });
    html += '</div>';
  }
  html += '<button onclick="this.parentElement.remove()" style="margin-top:16px;padding:10px 36px;font-size:16px;font-weight:900;font-family:Nunito,sans-serif;background:linear-gradient(180deg,#e94560,#c23152);color:#fff;border:3px solid #a02040;border-radius:50px;cursor:pointer;box-shadow:0 4px 0 #8b1a35;">è¿”å›</button>';
  lbEl.innerHTML = html; document.body.appendChild(lbEl);
});

// ===== è¾“å…¥ =====
canvas.addEventListener('click', e => { const r = canvas.getBoundingClientRect(); dropFruit((e.clientX - r.left) * (W / r.width)); });
canvas.addEventListener('mousemove', e => { const r = canvas.getBoundingClientRect(); previewX = (e.clientX - r.left) * (W / r.width); });
canvas.addEventListener('touchend', e => { e.preventDefault(); const r = canvas.getBoundingClientRect(); dropFruit((e.changedTouches[0].clientX - r.left) * (W / r.width)); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); const r = canvas.getBoundingClientRect(); previewX = (e.touches[0].clientX - r.left) * (W / r.width); });
$('restart-btn').addEventListener('click', () => { cleanup(); initGame(); });

initGame();
</script>
</body>
</html>
